import abc

from .rings import Ring, CommutativeRing, DivisionRing


class Domain(Ring, abc.ABC):
    """
    Class representing a domain. That is, a ring in which 0 is the only zero divisor.
    """

    @property
    def is_domain(self):
        return True

    def is_zero_divisor(self, a):
        return a == self.zero


class IntegralDomain(CommutativeRing, Domain, abc.ABC):
    """
    Class representing an integrity domain. That is, a commutative ring in which 0 is the only zero divisor.
    """


# TODO: seguir revisando todo esto, me quedé por aquí.
class UFD(IntegralDomain, DivisionRing, abc.ABC):
    """
    Class representing of an Unique Factorization Domain, a domain where all elements can be written as a product of
    prime elements (or irreducible elements), uniquely up to order and units.
    """

    def is_prime(self, p):
        """
        Determines whether the element p is prime or not. A prime element is a non zero element for which the principal
        ideal (p) generated by p is a nonzero prime ideal.
        :param p: self.dtype - element to be checked
        :return: bool - True if p is prime, False otherwise
        """
        raise NotImplementedError

    def factor(self, a):
        """
        Returns a list containing the unique prime factorization of a. If an element has multiplicity n,
        it will appear n times, and 1 won't be in the list.
        :param a: self.dtype - element to be factorized
        :return: [self.dtype] - list of prime elements that decompose a
        """
        raise NotImplementedError


class EuclideanDomain(UFD, abc.ABC):
    """
    Class representing an euclidean domain, a domain endowed with a Euclidean function which allows a suitable
    generalization of the Euclidean division of the integers. In any Euclidean domain, one can apply the Euclidean
    algorithm to compute the greatest common divisor of any two elements.
    """

    def value(self, a):
        """
        Computes the Euclidean function over a. A Euclidean function v : R\\{0} -> IZ+ must satisfy the following:
        - if b != 0 and there exist q, r such that a = b*q + r, then r = 0 or v(r) < v(b)
        - if b != 0, v(a) <= v(a*b)
        This function will vary depending on the ring.
        :param a: self.dtype - element for which compute the Euclidean function
        :return: int - result of applying the Euclidean function to a
        """
        raise NotImplementedError

    def quot(self, a, b):
        """
        Returns the quotient q of the division a = b * q + r.
        :param a: self.dtype - dividend
        :param b: self.dtype - divisor
        :return: self.dtype - quotient of the division
        """
        return self.full_div(a, b)[0]

    def rem(self, a, b):
        """
        Returns the remainder r of the division a = b * q + r.
        :param a: self.dtype - dividend
        :param b: self.dtype - divisor
        :return: self.dtype - remainder of the division
        """
        return self.full_div(a, b)[1]

    def full_div(self, a, b):
        """
        Returns both the quotient q and the remainder r of the division a = b * q + r.
        :param a: self.dtype - dividend
        :param b: self.dtype - divisor
        :return: (self.dtype, self.dtype) - quotient and remainder of the division
        """
        raise NotImplementedError

    def divides(self, a, b):
        """
        Determines whether a divides b or not (a|b), that is if there exists an element c for which b = a * c.
        :param a: self.dtype - left-hand-side element
        :param b: self.dtype - right-hand-side
        :return: bool - True if a|b, else False
        """
        return self.rem(a, b) == self.zero

    def gcd(self, a, b):
        """
        Returns the greatest common divisor of a and b, that is, the greatest element which divides both a and b.
        :param a: self.dtype - left-hand-side element
        :param b: self.dtype - right-hand-side element
        :return: self.dtype - greatest common divisor of a and b
        """
        raise NotImplementedError

    def lcm(self, a, b):
        """
        Returns the least common multiple of a and b, that is, the lowest element which is divided by both a and b.
        :param a: self.dtype - left-hand-side element
        :param b: self.dtype - right-hand-side element
        :return: self.dtype - least common multiple of a and b
        """
        return self.quot(self.mul(a, b), self.gcd(a, b))

    def bezout(self, a, b):
        """
        Returns two elements that satisfy Bezout's identity, that is, two elements x and y for which
        gcd(a, b) = a * x + b * y. It also returns the gcd of a and b.
        :param a: self.dtype - left-hand-side element
        :param b: self.dtype - right-hand-side element
        :return: ((self.dtype, self.dtype), self.dtype) - two elements that satisfy Bezout's identity and gcd(a, b)
        """
        raise NotImplementedError
