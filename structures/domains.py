import abc

from .polynomials import PolynomialUFD
from .rings import Ring, CommutativeRing, UnitaryRing


class Domain(Ring, abc.ABC):
    """
    Class representing a domain. That is, a ring in which 0 is the only zero divisor.
    """

    @property
    def is_domain(self):
        return True

    def is_zero_divisor(self, a):
        return a == self.zero


class IntegralDomain(CommutativeRing, Domain, abc.ABC):
    """
    Class representing an integral domain. That is, a commutative ring in which 0 is the only zero divisor.
    """

    def normal_part(self, a):
        """
        Returns the normal part of the given element a. The unit normal element of an unit normal class
        [a] := {b: a = bu, is_unit(u)} is the canonical representative of that class. The normal part of a satisfies
        a = n(a) * u(a).
        :param a: self.dtype - element for which compute its normal part
        :return: self.dtype - normal part of a
        """
        raise NotImplementedError

    def unit_part(self, a):
        """
        Returns the unit part of the given element a. The unit normal element of an unit normal class
        [a] := {b: a = bu, is_unit(u)} is the canonical representative of that class. The unit part of a satisfies
        a = n(a) * u(a).
        :param a: self.dtype - element for which compute its unit part
        :return: self.dtype - unit part of a
        """
        raise NotImplementedError


class UFD(IntegralDomain, UnitaryRing, abc.ABC):
    """
    Class representing of an Unique Factorization Domain, an integral domain where all elements can be written as a
    product of prime elements (or irreducible elements), uniquely up to order and units.
    """

    def is_prime(self, p):
        """
        Determines whether the element p is prime or not. A prime element is a non zero element for which the principal
        ideal (p) generated by p is a nonzero prime ideal.
        :param p: self.dtype - element to be checked
        :return: bool - True if p is prime, False otherwise
        """
        raise NotImplementedError

    def factor(self, a):
        """
        Returns a list containing the unique prime factorization of a. If an element has multiplicity n,
        it will appear n times, and 1 won't be in the list.
        :param a: self.dtype - element to be factorized
        :return: [self.dtype] - list of prime elements that decompose a
        """
        raise NotImplementedError

    def __getitem__(self, var):
        return PolynomialUFD(self, var)


class EuclideanDomain(UFD, abc.ABC):
    """
    Class representing an euclidean domain, a domain endowed with a Euclidean function which allows a suitable
    generalization of the Euclidean division of the integers. In any Euclidean domain, one can apply the Euclidean
    algorithm to compute the greatest common divisor of any two elements.
    """

    def value(self, a):
        """
        Computes the Euclidean function over a. A Euclidean function v : R\\{0} -> IZ+ must satisfy the following:
        - if b != 0 and there exist q, r such that a = b*q + r, then r = 0 or v(r) < v(b)
        - if b != 0, v(a) <= v(a*b)
        This function will vary depending on the ring.
        :param a: self.dtype - element for which compute the Euclidean function
        :return: int - result of applying the Euclidean function to a
        """
        raise NotImplementedError

    def quot(self, a, b):
        """
        Returns the quotient q of the division a = b * q + r.
        :param a: self.dtype - dividend
        :param b: self.dtype - divisor
        :return: self.dtype - quotient of the division
        """
        return self.full_div(a, b)[0]

    def rem(self, a, b):
        """
        Returns the remainder r of the division a = b * q + r.
        :param a: self.dtype - dividend
        :param b: self.dtype - divisor
        :return: self.dtype - remainder of the division
        """
        return self.full_div(a, b)[1]

    def full_div(self, a, b):
        """
        Returns both the quotient q and the remainder r of the division a = b * q + r.
        :param a: self.dtype - dividend
        :param b: self.dtype - divisor
        :return: (self.dtype, self.dtype) - quotient and remainder of the division
        """
        raise NotImplementedError

    def divides(self, a, b):
        """
        Determines whether a divides b or not (a|b), that is if there exists an element c for which b = a * c.
        :param a: self.dtype - left-hand-side element
        :param b: self.dtype - right-hand-side
        :return: bool - True if a|b, else False
        """
        return self.rem(a, b) == self.zero

    def gcd(self, a, b, *args):
        """
        Returns the greatest common divisor of a and b, that is, the greatest element which divides both a and b.
        :param a: self.dtype - left-hand-side element
        :param b: self.dtype - right-hand-side element
        :param args: self.dtype - undefined number of extra elements to compute gcd for
        :return: self.dtype - greatest common divisor of a and b
        """
        r0 = self.normal_part(a)
        r1 = self.normal_part(b)
        while r1 != self.zero:
            r2 = self.rem(r0, r1)
            r0 = r1
            r1 = r2
        if args:
            return self.gcd(self.normal_part(r0), args[0], *args[1:])
        return self.normal_part(r0)

    def lcm(self, a, b):
        """
        Returns the least common multiple of a and b, that is, the lowest element which is divided by both a and b.
        :param a: self.dtype - left-hand-side element
        :param b: self.dtype - right-hand-side element
        :return: self.dtype - least common multiple of a and b
        """
        return self.quot(self.normal_part(self.mul(a, b)), self.gcd(a, b))

    def bezout(self, a, b):
        """
        Returns two elements that satisfy Bezout's identity, that is, two elements x and y for which
        gcd(a, b) = a * x + b * y. It also returns the gcd of a and b.
        :param a: self.dtype - left-hand-side element
        :param b: self.dtype - right-hand-side element
        :return: (self.dtype, (self.dtype, self.dtype)) - gcd(a, b) and the two elements that satisfy Bezout's identity
        """
        r0 = self.normal_part(a)
        r1 = self.normal_part(b)

        x0 = self.one
        y0 = self.zero
        x1 = self.zero
        y1 = self.one
        while r1 != self.zero:
            (q, r2) = self.full_div(r0, r1)
            x2 = self.sub(x0, self.mul(q, x1))
            y2 = self.sub(y0, self.mul(q, y1))
            (x0, x1, y0, y1, r0, r1) = (x1, x2, y1, y2, r1, r2)
        x0 = self.quot(x0, self.mul(self.unit_part(a), self.unit_part(r0)))
        y0 = self.quot(y0, self.mul(self.unit_part(b), self.unit_part(r0)))
        return self.normal_part(r0), (x0, y0)

    def are_coprime(self, a, b):
        """
        Returns whether a and b are coprime or not, that is, gcd(a, b) == 1.
        :param a: self.dtype - one element to check coprimality
        :param b: self.dtype - another element to check coprimality
        :return: bool - True if a and b are coprime, False otherwise
        """
        return self.gcd(a, b) == self.one
